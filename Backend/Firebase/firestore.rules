rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    // --- Users Collection (Flat) ---
    match /users/{uid} {
      // Allow reading any user profile
      allow read: if true; 
      
      // Allow owner to modify their own document
      // Also allow authenticated users to update friendIds/friends (for unfriend/accept logic)
      allow create: if isOwner(uid);
      allow update: if isOwner(uid) || (isSignedIn() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['friendIds', 'friends']));
      
      // Legacy Profile Subcollection (Must be allowed for fallback fetch)
      match /profile/info {
         allow read: if true;
         allow write: if isOwner(uid);
      }
      
      // --- Posts Subcollection ---
      match /posts/{postId} {
         allow read: if true;
         allow write: if isOwner(uid);
      }
      
      // --- Friend Requests ---
      // Mapping: users/{uid}/friendRequests/{requestUid}
      // Note: Repository uses friendRequestsReceived and friendRequestsSent, NOT friendRequests.
      // We must support ALL variations found in the code to be safe.
      
      match /friendRequests/{requestId} {
          allow read: if isOwner(uid);
          allow write: if isOwner(uid) || isSignedIn(); 
      }
      
      // --- Friend Requests & Friends (Bidirectional Handshake) ---
      
      // INBOX: users/{uid}/friendRequestsReceived/{senderUid}
      // docID is the Sender.
      match /friendRequestsReceived/{senderUid} {
          allow read: if isOwner(uid);
          // 1. Sender can create a request in my inbox
          allow create: if isSignedIn() && request.auth.uid == senderUid;
          // 2. Sender can cancel (delete) their request
          // 3. Me (Owner) can delete (Accept/Reject)
          allow delete: if isOwner(uid) || (isSignedIn() && request.auth.uid == senderUid);
      }
      
      // OUTBOX: users/{uid}/friendRequestsSent/{receiverUid}
      // docID is the Receiver.
      match /friendRequestsSent/{receiverUid} {
          allow read: if isOwner(uid);
          // 1. I can create my own sent requests
          allow create: if isOwner(uid);
          // 2. I can cancel (delete)
          // 3. Receiver can delete (when they Accept/Reject me)
          allow delete: if isOwner(uid) || (isSignedIn() && request.auth.uid == receiverUid);
      }
      
      // FRIENDS: users/{uid}/friends/{friendUid}
      // docID is the Friend.
      match /friends/{friendUid} {
          allow read: if isOwner(uid);
          // 1. I can edit my friends list
          // 2. A new Friend can add themselves to my list (during Accept handshake)
          // 3. A Friend can remove themselves (Unfriend)
          allow write: if isOwner(uid) || (isSignedIn() && request.auth.uid == friendUid);
      }
      
      // FOLLOWERS (Legacy/Social)
      match /followers/{followerId} {
         allow read: if true;
         allow write: if isSignedIn();
      }
      
      match /following/{followingId} {
         allow read: if true;
         allow write: if isSignedIn();
      }
      
      // --- Joined Events ---
      match /joinedEvents/{eventId} {
         allow read, write: if isOwner(uid);
      }
      
      // --- Saved Events ---
      match /savedEvents/{docId} {
        allow read, write: if isOwner(uid);
      }
      
      // --- Saved Posts ---
      match /saved_posts/{postId} {
        allow read, write: if isOwner(uid);
      }
      
      // --- Blocked ---
      match /blocked/{blockedId} {
        allow read, write: if isOwner(uid);
      }
      
      // --- Chats (1-on-1) ---
      match /chats/{peerUid} {
         allow read: if isOwner(uid);
         // Owner can always write, peer can write when sending messages
         // Hidden chat fields (isHidden, hiddenAt) can only be set by owner
         allow write: if isOwner(uid) || (isSignedIn() && request.auth.uid == peerUid);

         match /messages/{messageId} {
            allow read: if isOwner(uid);
            allow write: if isOwner(uid) || (isSignedIn() && request.auth.uid == peerUid);
         }
      }

      // --- Hidden PIN Security Fields ---
      // These fields are sensitive and should only be readable/writable by the owner
      // Fields: hiddenPinHash, hiddenPinSalt, hiddenPinAlgo, hiddenPinSetAt, hiddenPinFailCount, hiddenPinLockedUntil
      // Already covered by the users/{uid} rules above (isOwner for write)
      
      // --- Private Security Subcollection ---
      // Stores Hidden PIN hash/salt. Strictly private.
      match /private/{docId} {
          allow read, write: if isOwner(uid);
      }

      // --- Other Subcollections ---
      match /devices/{deviceId} {
        allow read, write: if isOwner(uid);
      }
    }

    // --- Friends Collection (Legacy/Fallback) ---
    match /friends/{uid} {
      allow read: if isOwner(uid);
      match /list/{friendUid} {
         allow read, write: if isOwner(uid); 
      }
    }

    // --- Events Collection ---
    match /events/{eventId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update, delete: if isSignedIn(); 

      match /attendees/{userId} {
        allow read: if true; 
        allow write: if isSignedIn();
      }

      match /messages/{messageId} {
        allow read: if true; 
        allow write: if isSignedIn();
      }
      
      match /join_requests/{userId} {
         allow read, write: if isSignedIn();
      }
    }
    
    // --- Public Announcements ---
    match /announcements/{announcementId} {
      allow read: if true;
      allow write: if false;
    }

    // --- Feed Items (Public Read) ---
    match /feed_items/{itemId} {
      allow read: if true; // Public feed
      allow write: if false; // Generated by functions
    }

    // --- Followers Collection ---
    match /followers/{uid} {
      allow read: if true;
      match /list/{followerUid} {
         allow read: if true;
         // Allow write if I am the follower adding myself to someone's list
         allow write: if isSignedIn() && request.auth.uid == followerUid;
      }
    }

    // --- Following Collection ---
    match /following/{uid} {
      allow read: if true;
      match /list/{followingUid} {
         allow read: if true;
         // Allow write if I am the owner modifying my following list
         allow write: if isOwner(uid);
      }
    }
    
    // --- Posts Collection (Root) ---
    match /posts/{postId} {
      allow read: if true;
      allow create: if isSignedIn();
      // Allow update/delete if creator or if simply signed in for dev unblocking
      allow update, delete: if isSignedIn(); 
    }
    
    // Validations
    function validateUserUpdate() {
       return true; // Simplified for now to prevent strict type blocking during dev
       // return request.resource.data.username is string && request.resource.data.username.size() >= 3;
    }
    
    function validateEventCreate() {
       return request.resource.data.title is string &&
              request.resource.data.title.size() > 0 &&
              request.resource.data.isPrivate is bool;
    }
    
    function validateMessage() {
       return request.resource.data.type in ['text', 'image', 'system'] &&
              (request.resource.data.type == 'text' ? (request.resource.data.text is string && request.resource.data.text.size() > 0) : true) &&
              request.resource.data.timestamp is timestamp;
    }
  }
}
